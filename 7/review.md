# review

## 总结：

CPI（code pointer integrity）是一种用于保护非托管式语言（unmanaged language）如C/C++内存安全的技术。这篇文章针对CPI的安全性，利用它没有对数据指针进行保护，以及在不支持段保护机制的机器（如x86-64或者ARM架构）上采用信息隐藏方法来保护安全区（safe region）这两个设计漏洞，提出了一种用时间侧信道攻击来泄漏安全区域内容从而实现劫持攻击的方案。

攻击过程：

1. 找到数据指针漏洞。利用堆栈溢出导致的重写，获得一个可影响控制流的数据指针。
2. 信息采集。时间侧信道攻击需要采集足够的信息，以识别安全区域内每个byte的内容。通过累积时间分析将微小的时间延迟放大到足够区分，然后用byte 0来获得基准时间，用于消除网络延迟等影响因素。最后，求得byte 0-255对应的所有映射累积时间。
3. 定位安全区域。CPI的安全区域在空间上是紧随linked library的，同时受ASLR的保护，linked library的基址是在一个范围内随机选择的。因此，只要找到linked library的基址，就可以找到安全区域的基址。寻找有两种方式：non-crash方式以libc_size为步长不断扫描，耗时长但安全；crash方式利用二分法可以实现最多19次crash就找到。当crash后基址被ASLR随机化设置时，同样可以取得在T次crash后准确定位的理论成功概率。
4. 攻击安全区域。一旦获得安全区域的地址，就可以劫持ptr_address指针从而指向ROP链而完成攻击过程。

实验结果：实验评估是在Nginx 1.6.2上完成的，利用栈溢出获得数据指针。时间侧信道攻击对byte的识别精度达到2%，其中对byte 0可以实现近乎完美的识别。安全区域的定位上，library区识别到byte 0而导致假阳率的可能性为6.5%。最终，non-crash方式成功定位安全区域花了98小时，而crash方式则仅需要6秒。

提高CPI的安全防御：可以通过增加或减小安全区域的大小，随机化安全区域位置，利用哈希函数，以及使用非连续的mmap等方式来提高CPI受攻击的难度。

二、观点：

（1）优点：

1. 设计了一整套对CPI的攻击模式，阐明并成功实施了对CPI的攻击；
2. 巧妙地利用了时间侧信道攻击方法，获取内存中byte的数值，从而定位到CPI所隐匿的位置，实现了即使没有指针显式指向安全区域也可以定位的方案；
3. 实现了non-crash和crash两种攻击模式，从隐匿性和快速性两方面给予不同选择，同时者两种方法都保证了足够高的攻击成功率。

（2）缺点：

1. non-crash模式虽然不会引发crash，但是这种方法可能会被logging下来，因此也难以实现神不知鬼不觉的攻击；
2. 作者只是针对CPI中一个比较弱的实现进行攻击，在其他CPI强部署实现或者x86 32位环境中无法成功攻击。
