# review

##小结

本文提出了一种新的操作系统组织架构方案——“Nested Kernel”，将同一级ring0硬件权限划分成nested kernel和outer kernel两个区域，同时还定义了一些内核写保护机制用于保障系统的安全性。

Nested Kernel架构设计：将宏内核划分成两个区域，nested kernel区拥有完全的系统权限，而outer kernel是不可信的，需要通过虚拟MMU (vMMU)来对物理MMU (pMMU).进行修改，因而存在一个从虚拟到物理的映射机制。为此，提出了6条设计原则，包括了资源控制分离、系统的系统设计与显式接口、权限分离、最小依赖、细粒度的资源控制以及最少性能影响。对MMU的访问方面定义了2条属性特性，即outer kernel执行时虚-实映射的只读和写保护特性。

PerspicuOS原型设计：根据Nested Kernel架构，在x86的64位处理器上（支持MMU 写保护的使能）设计了一个原型系统，即PerspicuOS。通过对outer kernel权限降级，从而确保其无法关闭写保护（包括WP-bit和MMU）。针对Nested Kernel架构中提到了2条属性特性，提出了一系列设计特性来维持其完整性。为确保在outer kernel执行之前，所有对保护页的映射访问都是只读的，先对系统进行初始化。为了让outer kernel可以对pMMU进行配置以及保证适度的隔离，定义了一系列的nested kernel操作。PerspicuOS对内核代码进行静态（扫描二进制代码）和动态（运行时配置处理器和pMMU）两层审查，以确保内核代码全生命周期的完整性。为了保证在虚权限转移时系统的安全性，PerspicuOS做了一系列设计。定义了Nested Kernel的出入口来进行权限转移的准备（中断、写保护等），定义了Nested Kernel栈来存储当前outer kernel栈指针便于退出返回，设计了一个机制保证当vMMU mediation被绕过时，outer kernel对受保护状态的修改将触发写违例。为保证寄存器状态的一致性，当在outer kernel执行时，nested kernel不会映射某些页面（包含了对寄存器操作的指令）。针对受保护的数据结构的分配问题，作者修改了连接器的脚本，将写保护ELF区放在单独的页面中实现分离。为简化部署，简单地将mediation functions放在TCB中。最后，在FreeBSD 9.0上部署了
PerspicuOS原型并做了部分修改。

内核的安全性设计：定义了三种写保护的机制，分别是：一次写、追加和写日志。一次写通过维持一个向量来记录每一个比特是否已被修改，可用于保护系统调用表在初始化后不被恶意修改。追加通过维持一个带尾指针的列表结构，可用于记录系统调用操作。写日志机制对所有的写操作进行记录。

PerspicuOS性能验证：以FreeBSD系统为基准对各项指标进行验证，结果表明在系统调用方面稍微有点延迟，在对性能影响上有着非常小的负担。

## 观点：

优点：

1. 将内核划分成nested kernel和outer kernel两个区域，实现了权限的分离；
2. 定义了3种内核写保护机制用于保障系统的安全性，分别是：一次写、追加和写日志。

缺点：

1. 当nested kernel执行时，简单粗暴地将中断关闭，这不是最佳的解决方法；
2. 追加（Append-Only）和写日志（Write Logging）操作没有将记录备份到磁盘，易发生丢失，在操作的同时进行大量的记录，也会产生较大的额外开销，影响性能；
3. 对DMA没有过多额外的设计考虑；
4. 减少了TCB，增加了不可信区域检查的工作负担。
