# review

## 总结

目前的NVM文件系统（NVMFS）使用日记机制和同步cache刷新的方式来保证一致性，这种方式带来非常大的性能下降。针对这一问题，作者利用软件更新的方式来提高NVMFS的性能，同时结合字节寻址，降低了软件更新中依赖关系的追踪和持久化所带来的复杂度，实现了SoupFS系统，在保证一致性和正确性的同时，在延迟和吞吐量等指标上取得不错的效果。

软件更新方式通过延迟写、追踪指针依赖以及确保依赖可以持久化到磁盘等一系列方式，可以取得较小的延迟和较高的输出，但是却带来了较高的复杂性，给部署和使用带来诸多困难。通过结合字节寻址的方式，可以简化软件更新的设计，从而降低复杂度。配合字节寻址和软件更新，可以最大化NVMFS的性能。

系统设计与实现：首先，用哈希表来重构目录的组织方式，表项指向一个由4部分组成的固定长度的数据结构dentry，包含了文件名、inode、最新的下一个dentry和一致的下一个dentry。内存分配器对内存的作用是不可知的，因此只关心两种类型的结构，对应页大小（4KB）和cache行大小（64KB）两种规格，文件系统中的所有数据结构都被分配为这两种规格。更新依赖关系定义了3条规则，系统所有的更新操作（创建或删除文件，文件内容的增加或减少等）都需要遵循这3条规则。SoupFS提供了基于指针的双视图，当前最新视图对应了内存中操作，一致化视图对应了NVM已经持久化的操作，双视图消除了同步写所带来的性能下降。系统中大部分的数据结构都是由这两种视图共享（如文件名、B数节点、数据块），其他非共享的数据结构包括了：Inode在最新视图中是由VFS inode提供的，dentry中后两个指针分别对应两种视图的结构，两种视图各维持一个目录的哈希表。依赖关系的追踪通过一种以inode为中心的脏表（dirty inode list）来维持，每一个VFS inode中包含了一个操作列表来追踪当前节点对应的所有未持久化的操作以及相关的数据信息，这些操作在执行系统调用的时候记录到脏表中。SoupFS的依赖关系通过一个守护进程persister来实现，周期性地扫描脏表，并将其中的操作按顺序持久化到磁盘中。系统的原子性写操作是基于Inter RTM技术。由于一致性视图的存在，SoupFS在crash之后，不用进行系统的全局检查和恢复。

性能评估：实验评估分为微观和宏观基准测试两部分，SoupFS选取了4个Linux文件系统作为对比对象，分别是：EXT4、EXT4-DAX、PMFS和NOVA。微基准测试分为文件操作测试和目录操作测试，评估结果表明SoupFS具有最好的吞吐量和最小的延迟。宏基准测试主要选取了Filebench作为测试内容，测试结果表明在不同的线程下，SoupFS依旧能取得最佳的吞吐量，但由于NUMA架构的限制，在线程数量超过8时性能有所下降。

## 观点

一、优点

1. 结合字节寻址的方式，简化了软件更新，从而可以应用到NVM中；
2. 利用哈希表来重构原本以块为组织结构的目录，消除了伪共享（false	sharing），避免线性查找。
3. 设计了基于指针的双视图，避免了同步写带来的性能低下问题，同时一致性视图也保障了crash后系统立即可用。
4. 设计了语义感知的依赖关系追踪和持久化，保存了未持久化操作的次序。

二、缺点

1. 内存分配器对内存的分配比较粗糙，cache行大小的64B没有被充分利用，造成空间的浪费；
2. 双视图的结构也占据了比较多的空间资源，以空间换时间，避免了同步写的同时，产生比较多的空间开销；
