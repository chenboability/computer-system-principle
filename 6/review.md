# review

## 总结：

这篇文章通过运行一段预先设计的Java程序，利用引发的软内存错误（soft memory errors）安全漏洞，对Java或者.NET等将链接时类型检查作为保护机制的虚拟机进行攻击，绕过系统从而获取控制权，实现系统数据的任意读取和修改。

攻击的Java程序：程序定义了AB两种数据类型，接着在堆空间中分配多个B实例以及一个A实例，并将所有B实例中的A属性都指向那个唯一的A实例对象。当任意一个B实例的某个A属性中的一个比特由于某些原因（如宇宙射线）发生比特反转（01互换）时，这个A属性间接引用对象的b属性有很大的可能会指向一个A类型，这样可以获取到p和q两个类型分别为A和B的对象，它们都指向同一块内存，由此引发安全漏洞。攻击者只需要两行代码，即“p.i = address - offset ; q.a6.i = value ;”，便可以对任意内存地址address进行读取和修改。对一个32位的指针，其可用的攻击范围是从2-27位，总共26个位数，说明可利用的比特反转位数还是比较多的，攻击的效率比较高。

实验验证：采用两款商用Java虚拟机（IBM和Sun）进行实验。IBM进程空间中的单个比特反转实验可利用的比特数为70%，IBM物理内存空间中任意一个比特反转实验可利用的比特数为32%（实验结果33%），而Sun的结果为34%（实验结果38%）。实验结果中成功的攻击（虚拟机不崩溃，可控制）比例为71.4%。若为了进一步保证攻击的安全性，不搞垮虚拟机，将可用的攻击比特位数范围从2-27减少到10-27，则成功的攻击比例提高到93.7%。

攻击与防御：作者设想了各种可能的攻击方法（alpha射线、beta射线、x射线…），最终决定用可操作性比较强的加热方法。利用一个射灯对内存芯片进行加热，迫使比特反转的发生。为了应对这种攻击，作者建议应该在内存，特别是DRAM，加入纠错码ECC，此外在内存总线上也应该加入纠错码。最后，还可以通过日志记录的方式来记录和防止攻击，检测单比特反转来预测潜在的攻击。

## 观点：

（1）优点：

1. 从引发软内存错误的角度出发，脑洞大开地想到通过物理攻击（射线、加热等）迫使比特反转，导致产生安全漏洞，进而获取虚拟机的控制权；
2. 巧妙地设计了一段攻击代码，对代码的成功攻击概率进行了详细的分析，并在实际的实验中对可行性和攻击概率做了验证。

（2）缺点：

1. 虽然这种攻击程序导致的成功攻击概率较高，但是其诱导的比特反转却在正常环境中难以发生，因而攻击的可操作性不强，需要天时地利人和，代价大；
2. 实验中，IBM进程空间中的单个比特只说明了理论上可用到70%的程序空间比特反转，没有用实验证明结果的一致性；

