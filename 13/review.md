# review

## 总结

在系统crash后保持数据的一致性和持久性是非常重要的，回滚恢复以及日志机制是两种常用的方法，同时这种方法需要底层的文件系统对应用程序本身的数据（如对用户数据保护的日志文件）提供保护，然而，这种对日志程序进行日志保护的方法（journaling of journal）在实际应用中带来了较大的性能下降。这种性能下降主要源于当前文件系统对应用程序所保护的数据提供了过多没有必要的日志（因为这个可以让应用程序来完成），主要是一些额外的i/o，包括了增加i/o操作数和增加写的量。针对这一问题，作者提出了两点改进方法，小修改，大收益。

改进一：单i/o日志方法。在同步i/o提交的关键路径上不应该对文件或者元数据进行直接写，如函数ext4_sync_file()，这种操作将降低同步提交的速度。为此，文章在同步i/o提交的关键路径上执行单i/o操作，将应用程序的多个i/o整合到单次commit。

改进二：文件模式可变方法。由于一般的日志机制将一整个页用于日志记录，导致了即使只需要记录几个字节大小的数据也会需要一整个4KB的页，从而导致难以在 “单i/o全数据/元数据”或者“只记录元数据的顺序日志”这两种模式中选择。而一种模式可变的日志方法虽然可以为不同事务选择不同模式，但是在crash之后的恢复阶段可能会导致重写顺序的错误，并且在部署上也要许多困难。为此，文章提出一种粗粒度的模式可变日志方法，以文件为粒度选择日志模式，从而可以解决上述两个问题。通过设置每个文件的inode flag，指定该文件的日志模式，如写前记录（write-ahead log）类型的文件适合“顺序日志”模式而回滚恢复（rollback-recovery log）类型的文件适合“全数据/元数据”模式。

实验部署和评估：实验环境为Google Nexus 7和配备Intel 311的传统机器，选取的文件系统为Ext4，应用程序为SQLite数据库。性能测试主要是对数据库进行增加、删除和更新操作，无论是单i/o日志方法还是文件模式可变方法，在最差延迟方面都有较大提升，甚至在某些测试上的性能优于无日志的基准测试方法，显示出两种改进措施对性能具有较明显的提高。事务数据保护方面的测试结果表明，与没有任何保护相比，应用程序级的保护带来的代价是非常大的，小事务级操作增加1个量级的代价而大事务级也带来了接近2倍的代价。应用程序+带文件模式可变方法的文件系统级保护所产生的代价有所降低，显示出文章所做改进的有效性。

## 观点

一、优点

1. 准确地找到了文件系统对日志程序进行日志保护的方法（journaling of journal）在应用中带来了性能下降的原因；
2. 提出了“单i/o日志方法”和“文件模式可变方法”两种改进方法，有效地降低了journaling of journal对性能的影响；
3. 对原有代码的改进非常小（几十行代码），带来的性能提升却非常明显。

二、缺点

1. 性能评估方面，对于提出的两点改进措施的评估是分离的，没有提出将两者结合所带来的性能提高；
2. 实验部分较为简略，没有在其他数据管理程序上进行对应的实验；
3. 没有与改进二中Prabhakaran提出的模式可变的日志方法之间进行相应的对比。
